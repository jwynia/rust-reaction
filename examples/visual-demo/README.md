# Visual Demo - Phase 4

This example demonstrates **Phase 4: Visual UI Component** - an interactive counter that runs as WASM in the browser and can be hot-reloaded with visual changes.

## What This Proves

✅ **WASM components can render interactive UIs**
✅ **Components can be compiled and loaded in the browser**
✅ **Visual hot-reload is possible** (different versions have different styles)
✅ **The full cycle works: Rust → WASM → Browser → Interactive**

## Prerequisites

You need:
- **Rust toolchain**: https://rustup.rs/
- **wasm-pack**: `cargo install wasm-pack`
- **wasm32 target**: `rustup target add wasm32-unknown-unknown`
- **A local web server** (any simple HTTP server will do)

## Building

From this directory:

```bash
# Build the WASM module
wasm-pack build --target web

# This creates pkg/ directory with:
# - visual_demo.js
# - visual_demo_bg.wasm
# - visual_demo.d.ts (TypeScript definitions)
```

## Running

You need a local web server to serve the files (browsers block WASM loading from `file://` URLs).

**Option 1: Python**
```bash
# Python 3
python -m http.server 8080

# Then visit: http://localhost:8080/public/
```

**Option 2: Node.js**
```bash
npx serve public -p 8080

# Then visit: http://localhost:8080
```

**Option 3: Rust**
```bash
cargo install basic-http-server
basic-http-server public

# Then visit: http://localhost:4000
```

## What It Does

### Interactive Counter

The demo loads a counter component that:
- Displays a count (starts at 0)
- Has Increment/Decrement/Reset buttons
- Renders directly to the DOM
- Runs entirely as WASM (no JavaScript logic)

### Hot-Reload Simulation

The demo includes buttons to "load different versions":
- **Version 1** - Blue theme (default)
- **Version 2** - Green theme (simulated)
- **Version 3** - Animated (simulated)

Currently versions 2 and 3 are simulated (same WASM). To see real hot-reload:

1. Modify `src/lib.rs` (change colors, text, layout)
2. Run `wasm-pack build --target web`
3. Refresh the browser
4. See your changes instantly!

### Real Hot-Reload Example

**Try this:**

1. Build and run the demo
2. See the blue counter
3. Edit `src/lib.rs` line 75 (the color):
   ```rust
   // Change from:
   color: #2563eb;

   // To:
   color: #10b981;
   ```
4. Rebuild: `wasm-pack build --target web`
5. Refresh browser
6. See green counter!

This simulates what Morpheus will do automatically when AI generates new code.

## Architecture

```
User Browser
├── index.html          # Web page
├── JavaScript          # Loads WASM, handles hot-reload
└── WASM Module         # Rust counter compiled to WASM
    ├── Counter struct  # Component state
    ├── increment()     # Business logic
    ├── decrement()
    ├── reset()
    └── render()        # DOM updates
```

## File Structure

```
examples/visual-demo/
├── Cargo.toml          # WASM library configuration
├── src/
│   └── lib.rs          # Counter component (Rust)
├── public/
│   └── index.html      # Web page + JavaScript
└── pkg/                # Generated by wasm-pack
    ├── visual_demo.js
    ├── visual_demo_bg.wasm
    └── ...
```

## How Hot-Reload Will Work

**Current (manual):**
1. Edit Rust code
2. Run `wasm-pack build`
3. Refresh browser
4. See changes

**Future (Morpheus automated):**
```rust
// User: "Make the counter green"
let modification = ai.generate("Make the counter green").await?;

// Morpheus compiles it
let wasm = compiler.compile(&modification).await?;

// Loads into browser (no refresh needed!)
app.hot_reload(wasm).await?;

// User sees green counter immediately
```

## What This Demonstrates

1. **Rust → WASM works** for UI components
2. **Interactive components** can run entirely in WASM
3. **DOM manipulation** from Rust is feasible
4. **Hot-reload concept** is proven (manual now, automatic later)

## Comparison to Phase 3

**Phase 3** (integration-test):
- Compiled Rust → WASM
- Loaded into ComponentRegistry
- Hot-reloaded (bumped version)
- All in terminal, no visuals

**Phase 4** (visual-demo):
- Same compilation and loading
- But now you SEE it in the browser
- Interactive UI that responds to clicks
- Visual proof that hot-reload works

## Next Steps

**Phase 5: AI Integration** would add:
- LLM generates the Rust code
- Compiler validates it
- Hot-reload happens automatically
- User sees changes without manual build

**Phase 6: Advanced Safety** would add:
- Permission enforcement (what APIs can component use?)
- State snapshots (undo/rollback)
- Sandboxed execution (component isolation)
- Audit logging (track all modifications)

## Known Limitations

**Current implementation:**
- Only one version actually builds (v1)
- No real hot-reload without browser refresh
- No state preservation across reloads
- Manual build step required

**These are addressed in later phases:**
- Phase 5: Automatic recompilation when AI generates code
- Phase 6: State preservation and rollback
- Production: Real hot-reload without refresh

## Troubleshooting

**WASM not loading?**
- Make sure you're using HTTP server, not file://
- Check browser console for errors
- Verify pkg/ directory exists
- Try rebuilding: `wasm-pack build --target web`

**Buttons not working?**
- Check browser console for JavaScript errors
- Verify counter object is in global scope: `window.counter`
- Make sure WASM loaded successfully

**Build errors?**
- Ensure wasm32 target installed: `rustup target add wasm32-unknown-unknown`
- Ensure wasm-pack installed: `cargo install wasm-pack`
- Check Rust version: `rustc --version` (should be recent)

## Resources

- [wasm-bindgen book](https://rustwasm.github.io/docs/wasm-bindgen/)
- [web-sys docs](https://rustwasm.github.io/wasm-bindgen/api/web_sys/)
- [Rust and WebAssembly](https://rustwasm.github.io/docs/book/)
