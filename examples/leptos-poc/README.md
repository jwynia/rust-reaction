# Leptos + Leptonic POC

**Proof-of-Concept:** Integrating Leptos framework + Leptonic UI component library for AI-generated self-modifying apps.

## The Problem We're Solving

Currently, Morpheus AI generates **raw HTML with inline styles**:

```rust
// Current approach (visual-demo/src/lib.rs)
display.set_inner_html(&format!(
    r#"<div style="text-align: center; padding: 40px;">
        <h1 style="font-size: 72px;">{}</h1>
        <button onclick="counter.decrement()"
                style="padding: 12px 24px; background: #ef4444;">
            - Decrement
        </button>
    </div>"#,
    self.count
));
```

**Problems:**
- AI reinvents UI primitives from scratch every time
- Inline HTML/CSS is error-prone
- No design system coherence
- No type safety

## The Solution: Leptos + Leptonic

Use existing Rust UI framework + component library so AI composes pre-built, tested components:

```rust
// New approach (this POC)
view! { cx,
    <Stack spacing=Size::Em(2.0)>
        <H1>{count}</H1>
        <Button color=ButtonColor::Danger on_press=decrement>
            "- Decrement"
        </Button>
    </Stack>
}
```

**Benefits:**
- ✅ AI composes pre-built components (Button, Stack, Alert, etc.)
- ✅ Type-safe (compile errors for incorrect usage)
- ✅ Consistent design system
- ✅ Aligns with v1 conclusion: use existing frameworks, don't build another

## What This POC Demonstrates

1. **Leptos components compile to WASM** using standard tooling (wasm-pack)
2. **Leptonic provides production-ready UI components** (buttons, layouts, alerts, cards, etc.)
3. **AI-friendly syntax** - structured, clear, easy to generate
4. **Works with Morpheus hot-reload architecture** - components can be swapped at runtime

## Quick Start

### 1. Build the Component

```bash
cd examples/leptos-poc

# Build with wasm-pack
wasm-pack build --target web --release
```

This generates:
- `pkg/leptos_poc.js` - JavaScript bindings
- `pkg/leptos_poc_bg.wasm` - Compiled WASM module
- `pkg/leptos_poc.d.ts` - TypeScript definitions

### 2. Serve the Demo

```bash
# Simple HTTP server (Python)
python3 -m http.server 8000

# Or using any static file server
# npm install -g http-server
# http-server -p 8000
```

### 3. Open in Browser

```
http://localhost:8000/public/
```

You should see:
- Side-by-side comparison of old vs new approach
- Working counter component using Leptonic UI
- Professional styling out-of-the-box

## Code Structure

```
examples/leptos-poc/
├── src/
│   └── lib.rs              # Leptos component using Leptonic UI
├── public/
│   └── index.html          # Demo page that loads the component
├── pkg/                    # Generated by wasm-pack (gitignored)
│   ├── leptos_poc.js
│   ├── leptos_poc_bg.wasm
│   └── ...
├── Cargo.toml              # Dependencies: leptos + leptonic
└── README.md               # This file
```

## Component Code

The POC component (`src/lib.rs`) demonstrates:

### Using Leptonic Components

```rust
use leptos::*;
use leptonic::prelude::*;

#[component]
pub fn Counter(cx: Scope) -> impl IntoView {
    let (count, set_count) = create_signal(cx, 0);

    view! { cx,
        <Root default_theme=LeptonicTheme::default()>
            <Stack spacing=Size::Em(2.0)>
                <H1>{move || count.get()}</H1>

                <Stack orientation=StackOrientation::Horizontal spacing=Size::Em(1.0)>
                    <Button on_press=|_| set_count.update(|n| *n -= 1) color=ButtonColor::Danger>
                        "- Decrement"
                    </Button>
                    <Button on_press=|_| set_count.set(0) color=ButtonColor::Secondary>
                        "Reset"
                    </Button>
                    <Button on_press=|_| set_count.update(|n| *n += 1) color=ButtonColor::Success>
                        "+ Increment"
                    </Button>
                </Stack>

                <Alert variant=AlertVariant::Info>
                    <AlertTitle>"Morpheus Counter - Leptos Edition"</AlertTitle>
                    <AlertDescription>
                        "This uses pre-built components instead of raw HTML!"
                    </AlertDescription>
                </Alert>
            </Stack>
        </Root>
    }
}
```

### Available Leptonic Components

This POC uses:
- **Layout:** `<Stack>`, `<Box>`
- **Typography:** `<H1>`, `<P>`
- **Buttons:** `<Button>` with color variants
- **Feedback:** `<Alert>` with title and description
- **Data Display:** `<Card>` with header and body

Many more available: Input, TextArea, Select, Checkbox, Radio, Toggle, Modal, Drawer, Tabs, Table, etc.

## Comparison: Old vs New

### Old Approach (visual-demo)
- **Lines of code:** ~118 lines
- **Inline HTML strings:** Yes
- **Inline CSS:** Yes
- **Type safety:** No (string manipulation)
- **Components:** None (raw HTML)
- **Design system:** Manual (error-prone)
- **AI task:** Generate complete HTML/CSS structure

### New Approach (leptos-poc)
- **Lines of code:** ~95 lines (smaller!)
- **Inline HTML strings:** No
- **Inline CSS:** No (styled by Leptonic)
- **Type safety:** Yes (compile-time errors)
- **Components:** Pre-built, tested (Leptonic library)
- **Design system:** Built-in, consistent
- **AI task:** Compose existing components (easier!)

## Integration with Morpheus

### How This Fits Into Self-Modifying Apps

1. **AI generates Leptos code** using Leptonic components
2. **SubprocessCompiler compiles it** to WASM (same as now, but with Leptos deps)
3. **Hot-reload into browser** (existing mechanism)
4. **Component mounts** via `mount()` function

### Required Changes to Morpheus

1. **Update AI system prompt** to generate Leptos components
2. **Update compiler template** to include Leptos + Leptonic dependencies
3. **Update frontend loader** to call Leptos `mount()` instead of custom init
4. **Test compilation speed** with framework included

Details in: `context-network/planning/component-library-integration.md`

## Measurements & Findings

### Compilation Time
```bash
time wasm-pack build --target web --release
```

**Results:** _(to be filled after first successful build)_
- Cold build: ?
- Incremental build: ?
- Release build: ?

### WASM Bundle Size
```bash
ls -lh pkg/*.wasm
```

**Results:** _(to be filled)_
- Uncompressed: ?
- After wasm-opt: ?
- Gzipped: ?

### Runtime Performance
- Initial load: ?
- Reactivity updates: ?
- Memory usage: ?

## Next Steps

### If POC Succeeds ✅

1. **Update morpheus-complete** to use this approach
2. **Update AI system prompt** with Leptos/Leptonic examples
3. **Test AI generation** - can Claude reliably generate valid Leptos code?
4. **Measure iteration speed** - is compilation fast enough for AI loop?
5. **Build component library** - document available components for AI

### If POC Fails ❌

1. **Try simpler approach** - web components? CSS framework?
2. **Consider Dioxus** - different syntax, might be easier for AI
3. **Hybrid approach** - templates for common patterns?
4. **Document why** - what didn't work, what did we learn?

## Open Questions

1. **Compilation Speed:** Is compiling Leptos + Leptonic fast enough for AI iteration?
   - Target: <10 seconds for typical component
   - Test: Build several components of varying complexity

2. **AI Generation Quality:** Can AI reliably generate valid Leptos code?
   - Test: Give Claude the Leptonic docs, ask for various components
   - Measure: Success rate on first attempt

3. **Bundle Size:** Are WASM bundles reasonable?
   - Test: Measure compressed size
   - Compare: vs current raw HTML approach

4. **Component Coverage:** Does Leptonic have enough components?
   - Check: Forms, tables, modals, navigation
   - Consider: Mixing libraries if needed

## Related Documents

- **Proposal:** `context-network/planning/component-library-integration.md`
- **Original v1 framework:** `archive/prototype-v1/`
- **Decision to pivot:** `context-network/decisions/002-self-modifying-apps-pivot.md`
- **Current AI generation:** `examples/morpheus-complete/`

## License

MIT OR Apache-2.0
