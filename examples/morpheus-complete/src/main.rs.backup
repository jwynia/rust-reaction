//! Morpheus Complete - The Full System
//!
//! Integrates all 6 phases into one production-ready application:
//! - AI code generation with error retry (Phase 5)
//! - Runtime compilation (Phase 1)
//! - Hot-reload (Phase 2/3)
//! - Visual UI (Phase 4)
//! - State preservation (Phase 6)
//! - Version history & rollback (Phase 6)

use axum::{
    extract::State,
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{get, post},
    Json, Router,
};
use chrono::{DateTime, Utc};
use morpheus_compiler::{Compiler, SubprocessCompiler};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{error, info, warn};

/// Application state
#[derive(Clone)]
struct AppState {
    compiler: Arc<SubprocessCompiler>,
    versions: Arc<Mutex<VersionHistory>>,
    conversation: Arc<Mutex<Vec<Message>>>,
    design_session: Arc<Mutex<Option<DesignSession>>>,
    api_key: String,
}

/// Interactive design session for iterative component development
#[derive(Clone)]
struct DesignSession {
    session_id: String,
    conversation: Vec<Message>,
    drafts: Vec<ComponentDraft>,
    current_draft_index: usize,
    original_prompt: String,
    started_at: DateTime<Utc>,
}

/// A draft component during the design process
#[derive(Clone, Serialize, Deserialize)]
struct ComponentDraft {
    iteration: usize,
    prompt: String,
    rust_code: String,
    wasm_base64: Option<String>,
    compilation_error: Option<String>,
    created_at: DateTime<Utc>,
}

/// Version history manager
#[derive(Clone)]
struct VersionHistory {
    versions: Vec<ComponentVersion>,
    current_index: usize,
    current_state: Option<serde_json::Value>,
}

/// A versioned component snapshot
#[derive(Clone, Serialize, Deserialize)]
struct ComponentVersion {
    id: usize,
    name: String,
    description: String,
    rust_code: String,
    wasm_base64: String,
    created_at: DateTime<Utc>,
    state_snapshot: Option<serde_json::Value>,
    ai_generated: bool,
}

impl VersionHistory {
    fn new() -> Self {
        Self {
            versions: Vec::new(),
            current_index: 0,
            current_state: None,
        }
    }

    fn add_version(
        &mut self,
        name: String,
        description: String,
        rust_code: String,
        wasm_bytes: Vec<u8>,
        ai_generated: bool,
    ) -> usize {
        let id = self.versions.len();
        let version = ComponentVersion {
            id,
            name,
            description,
            rust_code,
            wasm_base64: base64_encode(&wasm_bytes),
            created_at: Utc::now(),
            state_snapshot: self.current_state.clone(),
            ai_generated,
        };

        self.versions.push(version);
        self.current_index = id;
        id
    }

    fn get_current(&self) -> Option<&ComponentVersion> {
        self.versions.get(self.current_index)
    }

    fn rollback_to(&mut self, version_id: usize) -> Option<&ComponentVersion> {
        if version_id < self.versions.len() {
            self.current_index = version_id;
            if let Some(version) = self.versions.get(version_id) {
                self.current_state = version.state_snapshot.clone();
            }
            self.get_current()
        } else {
            None
        }
    }

    fn update_state(&mut self, state: serde_json::Value) {
        self.current_state = Some(state);
    }

    fn get_history(&self) -> Vec<VersionSummary> {
        self.versions
            .iter()
            .map(|v| VersionSummary {
                id: v.id,
                name: v.name.clone(),
                description: v.description.clone(),
                created_at: v.created_at.to_rfc3339(),
                is_current: v.id == self.current_index,
                ai_generated: v.ai_generated,
            })
            .collect()
    }
}

/// Version summary for history display
#[derive(Serialize)]
struct VersionSummary {
    id: usize,
    name: String,
    description: String,
    created_at: String,
    is_current: bool,
    ai_generated: bool,
}

/// A message in the AI conversation
#[derive(Clone, Serialize, Deserialize)]
struct Message {
    role: String,
    content: String,
}

/// Request to generate component with AI
#[derive(Deserialize)]
struct GenerateRequest {
    prompt: String,
}

/// Response to generation request
#[derive(Serialize)]
struct GenerateResponse {
    success: bool,
    version_id: Option<usize>,
    wasm_base64: Option<String>,
    restored_state: Option<serde_json::Value>,
    error: Option<String>,
    iterations: u32,
    logs: Vec<String>,
}

/// Request to update component state
#[derive(Deserialize)]
struct UpdateStateRequest {
    state: serde_json::Value,
}

/// Response to state update
#[derive(Serialize)]
struct UpdateStateResponse {
    success: bool,
}

/// Request to rollback to a version
#[derive(Deserialize)]
struct RollbackRequest {
    version_id: usize,
}

/// Response to rollback
#[derive(Serialize)]
struct RollbackResponse {
    success: bool,
    version_id: usize,
    wasm_base64: String,
    restored_state: Option<serde_json::Value>,
    error: Option<String>,
}

/// Get version history
#[derive(Serialize)]
struct HistoryResponse {
    versions: Vec<VersionSummary>,
    current_state: Option<serde_json::Value>,
}

/// Request to fix a runtime error
#[derive(Deserialize)]
struct FixErrorRequest {
    error_message: String,
    version_id: Option<usize>,
}

// ============================================================================
// Design Session API Structures
// ============================================================================

/// Request to start a new design session
#[derive(Deserialize)]
struct DesignStartRequest {
    prompt: String,
}

/// Response to design session start
#[derive(Serialize)]
struct DesignStartResponse {
    session_id: String,
    draft: DraftInfo,
    logs: Vec<String>,
}

/// Request to refine the current draft
#[derive(Deserialize)]
struct DesignRefineRequest {
    feedback: String,
}

/// Response to design refinement
#[derive(Serialize)]
struct DesignRefineResponse {
    success: bool,
    draft: DraftInfo,
    logs: Vec<String>,
    error: Option<String>,
}

/// Request to commit the current design
#[derive(Deserialize)]
struct DesignCommitRequest {
    message: Option<String>,
}

/// Response to design commit
#[derive(Serialize)]
struct DesignCommitResponse {
    success: bool,
    version_id: usize,
    wasm_base64: String,
    error: Option<String>,
}

/// Get current design preview
#[derive(Serialize)]
struct DesignPreviewResponse {
    active: bool,
    session_id: Option<String>,
    draft: Option<DraftInfo>,
    conversation: Vec<ConversationEntry>,
}

/// Information about a draft
#[derive(Serialize, Clone)]
struct DraftInfo {
    iteration: usize,
    prompt: String,
    wasm_base64: Option<String>,
    compilation_error: Option<String>,
    has_runtime_error: bool,
}

/// Conversation entry for display
#[derive(Serialize, Clone)]
struct ConversationEntry {
    role: String,
    content: String,
    timestamp: DateTime<Utc>,
}

/// Claude API structures (OpenRouter format)
#[derive(Serialize)]
struct ClaudeRequest {
    model: String,
    max_tokens: u32,
    messages: Vec<Message>,
}

#[derive(Deserialize)]
struct ClaudeResponse {
    choices: Vec<Choice>,
}

#[derive(Deserialize)]
struct Choice {
    message: ResponseMessage,
}

#[derive(Deserialize)]
struct ResponseMessage {
    content: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter("info,morpheus_compiler=debug")
        .init();

    info!("üß¨ Starting Morpheus - Complete System");

    // Load environment variables
    dotenvy::dotenv().ok();
    let api_key = std::env::var("OPENROUTER_API_KEY").unwrap_or_else(|_| {
        warn!("OPENROUTER_API_KEY not set - AI features will not work!");
        String::new()
    });

    // Check compiler tools
    SubprocessCompiler::check_tools()?;
    info!("‚úì Rust compiler and wasm-pack available");

    // Initialize compiler
    let compiler = SubprocessCompiler::new().await?;
    info!("‚úì Compiler initialized");

    // Create application state
    let state = AppState {
        compiler: Arc::new(compiler),
        versions: Arc::new(Mutex::new(VersionHistory::new())),
        conversation: Arc::new(Mutex::new(Vec::new())),
        design_session: Arc::new(Mutex::new(None)),
        api_key,
    };

    // Build router
    let app = Router::new()
        // Legacy endpoints (for backwards compatibility)
        .route("/api/generate", post(generate_component))
        .route("/api/fix", post(fix_runtime_error))
        // Design workflow endpoints
        .route("/api/design/start", post(design_start))
        .route("/api/design/refine", post(design_refine))
        .route("/api/design/commit", post(design_commit))
        .route("/api/design/preview", get(design_preview))
        .route("/api/design/cancel", post(design_cancel))
        // State management endpoints
        .route("/api/state", post(update_state))
        .route("/api/rollback", post(rollback))
        .route("/api/history", get(get_history))
        .route("/api/health", get(health_check))
        .nest_service("/", ServeDir::new("examples/morpheus-complete/public"))
        .layer(CorsLayer::permissive())
        .with_state(state);

    // Start server
    let addr = "127.0.0.1:3002";
    info!("üöÄ Morpheus running at http://{}", addr);
    info!("   The complete system - All 6 phases integrated!");

    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

/// Health check endpoint
async fn health_check() -> impl IntoResponse {
    Json(serde_json::json!({
        "status": "ok",
        "service": "morpheus-complete",
        "phases": ["compilation", "hot-reload", "integration", "visual-ui", "ai-loop", "safety"]
    }))
}

/// Generate component with AI (integrates Phase 5 + Phase 6)
async fn generate_component(
    State(state): State<AppState>,
    Json(req): Json<GenerateRequest>,
) -> Result<Json<GenerateResponse>, AppError> {
    info!("AI generation request: {}", req.prompt);

    let mut logs = Vec::new();
    logs.push(format!("üéØ User request: {}", req.prompt));

    // Check API key
    if state.api_key.is_empty() {
        return Err(AppError::ApiError(
            "OPENROUTER_API_KEY not configured".to_string(),
        ));
    }

    const MAX_ITERATIONS: u32 = 5;
    let mut iteration = 0;

    // Reset conversation
    let mut conversation = state.conversation.lock().await;
    conversation.clear();
    conversation.push(Message {
        role: "user".to_string(),
        content: create_system_prompt(),
    });
    conversation.push(Message {
        role: "user".to_string(),
        content: format!("Create a WASM component: {}", req.prompt),
    });
    drop(conversation);

    // AI + Compilation retry loop
    loop {
        iteration += 1;
        logs.push(format!("\n‚îÅ‚îÅ‚îÅ Iteration {} ‚îÅ‚îÅ‚îÅ", iteration));

        if iteration > MAX_ITERATIONS {
            logs.push("‚ùå Max iterations reached".to_string());
            return Ok(Json(GenerateResponse {
                success: false,
                version_id: None,
                wasm_base64: None,
                restored_state: None,
                error: Some("Failed after 5 attempts".to_string()),
                iterations: iteration - 1,
                logs,
            }));
        }

        // Call AI
        logs.push("ü§ñ Asking AI to generate Rust code...".to_string());
        let rust_code = match call_claude_api(&state).await {
            Ok(code) => {
                logs.push(format!("‚úì AI generated {} bytes of code", code.len()));
                code
            }
            Err(e) => {
                error!("Claude API error: {}", e);
                return Ok(Json(GenerateResponse {
                    success: false,
                    version_id: None,
                    wasm_base64: None,
                    restored_state: None,
                    error: Some(format!("AI API error: {}", e)),
                    iterations: iteration,
                    logs,
                }));
            }
        };

        // Compile
        logs.push("‚öôÔ∏è  Compiling Rust ‚Üí WASM...".to_string());
        match state.compiler.compile(&rust_code).await {
            Ok(wasm_bytes) => {
                // SUCCESS! Now save with state preservation (Phase 6)
                logs.push(format!(
                    "‚úÖ Compilation successful! {} bytes of WASM",
                    wasm_bytes.len()
                ));
                logs.push(format!("üéâ Component ready after {} iteration(s)", iteration));

                // Get current state for preservation
                let mut history = state.versions.lock().await;
                let restored_state = history.current_state.clone();

                // Add to version history with state preservation
                let version_name = format!("AI Generated: {}", truncate(&req.prompt, 40));
                let version_desc = req.prompt.clone();
                let version_id = history.add_version(
                    version_name,
                    version_desc,
                    rust_code,
                    wasm_bytes.clone(),
                    true, // AI generated
                );

                logs.push(format!("üìú Saved as version {} in history", version_id));
                if restored_state.is_some() {
                    logs.push("üîí State preserved from previous version!".to_string());
                }

                let wasm_base64 = base64_encode(&wasm_bytes);

                return Ok(Json(GenerateResponse {
                    success: true,
                    version_id: Some(version_id),
                    wasm_base64: Some(wasm_base64),
                    restored_state,
                    error: None,
                    iterations: iteration,
                    logs,
                }));
            }
            Err(e) => {
                // Compilation failed - feed error back to AI
                let error_msg = e.to_string();
                logs.push(format!("‚ùå Compilation failed:\n{}", error_msg));
                logs.push("üîÑ Feeding error back to AI for retry...".to_string());

                let mut conversation = state.conversation.lock().await;
                conversation.push(Message {
                    role: "assistant".to_string(),
                    content: rust_code,
                });
                conversation.push(Message {
                    role: "user".to_string(),
                    content: format!(
                        "That code failed to compile with this error:\n\n{}\n\nFix it.",
                        error_msg
                    ),
                });
                drop(conversation);

                // Loop continues for retry
            }
        }
    }
}

/// Fix runtime error by asking AI to regenerate
async fn fix_runtime_error(
    State(state): State<AppState>,
    Json(req): Json<FixErrorRequest>,
) -> Result<Json<GenerateResponse>, AppError> {
    info!("Fix runtime error request: {}", req.error_message);

    let mut logs = Vec::new();
    logs.push("üîß Attempting to fix runtime error...".to_string());
    logs.push(format!("‚ùå Error: {}", req.error_message));

    // Check API key
    if state.api_key.is_empty() {
        return Err(AppError::ApiError(
            "OPENROUTER_API_KEY not configured".to_string(),
        ));
    }

    // Get the failing component code from version history
    let history = state.versions.lock().await;
    let version_id = req.version_id.unwrap_or(history.current_index);
    let version = history.versions.get(version_id)
        .ok_or_else(|| AppError::ApiError("Version not found".to_string()))?;
    let failing_code = version.rust_code.clone();
    let original_prompt = version.description.clone();
    drop(history);

    logs.push(format!("üìù Original request: {}", original_prompt));

    // Update conversation with the error
    let mut conversation = state.conversation.lock().await;
    conversation.clear();
    conversation.push(Message {
        role: "user".to_string(),
        content: create_system_prompt(),
    });
    conversation.push(Message {
        role: "user".to_string(),
        content: format!("Create a WASM component: {}", original_prompt),
    });
    conversation.push(Message {
        role: "assistant".to_string(),
        content: failing_code,
    });
    conversation.push(Message {
        role: "user".to_string(),
        content: format!(
            "That code compiled successfully but failed at runtime with this error:\n\n{}\n\nThis is a WASM loading error. The issue is likely that the component uses wasm-bindgen imports that aren't available in the browser. Please rewrite the component to be simpler and avoid dependencies that require JavaScript glue code. Focus on basic functionality without external dependencies.",
            req.error_message
        ),
    });
    drop(conversation);

    const MAX_ITERATIONS: u32 = 5;
    let mut iteration = 0;

    // AI + Compilation retry loop
    loop {
        iteration += 1;
        logs.push(format!("\n‚îÅ‚îÅ‚îÅ Fix Iteration {} ‚îÅ‚îÅ‚îÅ", iteration));

        if iteration > MAX_ITERATIONS {
            logs.push("‚ùå Max iterations reached".to_string());
            return Ok(Json(GenerateResponse {
                success: false,
                version_id: None,
                wasm_base64: None,
                restored_state: None,
                error: Some("Failed to fix after 5 attempts".to_string()),
                iterations: iteration - 1,
                logs,
            }));
        }

        // Call AI
        logs.push("ü§ñ Asking AI to fix the code...".to_string());
        let rust_code = match call_claude_api(&state).await {
            Ok(code) => {
                logs.push(format!("‚úì AI generated {} bytes of fixed code", code.len()));
                code
            }
            Err(e) => {
                error!("Claude API error: {}", e);
                return Ok(Json(GenerateResponse {
                    success: false,
                    version_id: None,
                    wasm_base64: None,
                    restored_state: None,
                    error: Some(format!("AI API error: {}", e)),
                    iterations: iteration,
                    logs,
                }));
            }
        };

        // Compile
        logs.push("‚öôÔ∏è  Compiling fixed Rust ‚Üí WASM...".to_string());
        match state.compiler.compile(&rust_code).await {
            Ok(wasm_bytes) => {
                logs.push(format!(
                    "‚úÖ Compilation successful! {} bytes of WASM",
                    wasm_bytes.len()
                ));
                logs.push(format!("üéâ Fixed component ready after {} iteration(s)", iteration));

                // Get current state for preservation
                let mut history = state.versions.lock().await;
                let restored_state = history.current_state.clone();

                // Add to version history with state preservation
                let version_name = format!("AI Fixed: {}", truncate(&original_prompt, 40));
                let version_desc = format!("{} (fixed runtime error)", original_prompt);
                let new_version_id = history.add_version(
                    version_name,
                    version_desc,
                    rust_code,
                    wasm_bytes.clone(),
                    true, // AI generated
                );

                logs.push(format!("üìú Saved as version {} in history", new_version_id));
                if restored_state.is_some() {
                    logs.push("üîí State preserved from previous version!".to_string());
                }

                let wasm_base64 = base64_encode(&wasm_bytes);

                return Ok(Json(GenerateResponse {
                    success: true,
                    version_id: Some(new_version_id),
                    wasm_base64: Some(wasm_base64),
                    restored_state,
                    error: None,
                    iterations: iteration,
                    logs,
                }));
            }
            Err(e) => {
                // Compilation failed - feed error back to AI
                let error_msg = e.to_string();
                logs.push(format!("‚ùå Compilation failed:\n{}", error_msg));
                logs.push("üîÑ Feeding error back to AI for retry...".to_string());

                let mut conversation = state.conversation.lock().await;
                conversation.push(Message {
                    role: "assistant".to_string(),
                    content: rust_code,
                });
                conversation.push(Message {
                    role: "user".to_string(),
                    content: format!(
                        "That code failed to compile with this error:\n\n{}\n\nFix it.",
                        error_msg
                    ),
                });
                drop(conversation);

                // Loop continues for retry
            }
        }
    }
}

/// Update component state
async fn update_state(
    State(state): State<AppState>,
    Json(req): Json<UpdateStateRequest>,
) -> Result<Json<UpdateStateResponse>, AppError> {
    let mut history = state.versions.lock().await;
    history.update_state(req.state);
    Ok(Json(UpdateStateResponse { success: true }))
}

/// Rollback to previous version
async fn rollback(
    State(state): State<AppState>,
    Json(req): Json<RollbackRequest>,
) -> Result<Json<RollbackResponse>, AppError> {
    info!("Rolling back to version {}", req.version_id);

    let mut history = state.versions.lock().await;

    if let Some(version) = history.rollback_to(req.version_id) {
        Ok(Json(RollbackResponse {
            success: true,
            version_id: version.id,
            wasm_base64: version.wasm_base64.clone(),
            restored_state: version.state_snapshot.clone(),
            error: None,
        }))
    } else {
        Ok(Json(RollbackResponse {
            success: false,
            version_id: 0,
            wasm_base64: String::new(),
            restored_state: None,
            error: Some(format!("Version {} not found", req.version_id)),
        }))
    }
}

/// Get version history
async fn get_history(State(state): State<AppState>) -> Result<Json<HistoryResponse>, AppError> {
    let history = state.versions.lock().await;
    Ok(Json(HistoryResponse {
        versions: history.get_history(),
        current_state: history.current_state.clone(),
    }))
}

/// Call Claude API
async fn call_claude_api(state: &AppState) -> Result<String, AppError> {
    let conversation = state.conversation.lock().await;
    let messages = conversation.clone();
    drop(conversation);

    let client = reqwest::Client::new();
    let response = client
        .post("https://openrouter.ai/api/v1/chat/completions")
        .header("Authorization", format!("Bearer {}", &state.api_key))
        .header("HTTP-Referer", "https://github.com/morpheus-project")
        .header("X-Title", "Morpheus")
        .header("Content-Type", "application/json")
        .json(&ClaudeRequest {
            model: "anthropic/claude-3.5-sonnet".to_string(),
            max_tokens: 4096,
            messages,
        })
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await?;
        return Err(AppError::ApiError(format!(
            "Claude API returned {}: {}",
            status, body
        )));
    }

    let claude_response: ClaudeResponse = response.json().await?;
    let text = claude_response
        .choices
        .first()
        .map(|choice| choice.message.content.clone())
        .ok_or_else(|| AppError::ApiError("No content in response".to_string()))?;

    extract_rust_code(&text)
}

/// Extract Rust code from AI response
fn extract_rust_code(text: &str) -> Result<String, AppError> {
    if let Some(start) = text.find("```rust") {
        let after_marker = &text[start + 7..];
        if let Some(end) = after_marker.find("```") {
            return Ok(after_marker[..end].trim().to_string());
        }
    }

    if let Some(start) = text.find("```") {
        let after_marker = &text[start + 3..];
        if let Some(end) = after_marker.find("```") {
            return Ok(after_marker[..end].trim().to_string());
        }
    }

    Ok(text.trim().to_string())
}

/// Create system prompt for AI
fn create_system_prompt() -> String {
    r#"You are a Rust expert generating simple, reliable WebAssembly components using web-sys and wasm-bindgen.

CRITICAL RULES:
1. ONLY output Rust code - no explanations, no markdown formatting
2. Use web-sys for direct DOM manipulation - NO frameworks like Leptos/Yew
3. Keep it SIMPLE - basic DOM operations only
4. Use Tailwind CSS classes in your HTML strings for styling
5. Always export a render() function that returns the component as HTML string
6. NO reactivity frameworks - just return HTML

COMPONENT TEMPLATE:

use wasm_bindgen::prelude::*;
use web_sys::{window, document};

#[wasm_bindgen]
pub fn render() -> String {
    let doc = window().unwrap().document().unwrap();
    let body = doc.body().unwrap();
    
    // Create simple HTML with Tailwind classes
    let html = r#"
        <div class="p-6 max-w-2xl mx-auto">
            <h1 class="text-4xl font-bold text-gray-900 mb-4">Simple Component</h1>
            <button 
                onclick="alert('Clicked!')"
                class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                Click Me
            </button>
        </div>
    "#;
    
    body.set_inner_html(html);
    html.to_string()
}

TAILWIND CSS CLASSES (use these for styling):

Buttons:
- Primary: "px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
- Danger: "px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"  
- Success: "px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"

Inputs:
- "w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"

Containers:
- "max-w-2xl mx-auto px-4 py-6"
- "bg-white rounded-lg shadow-md p-6"

Layout:
- Flex: "flex gap-4 items-center justify-between"
- Grid: "grid grid-cols-2 gap-4"

Typography:
- H1: "text-4xl font-bold text-gray-900"
- H2: "text-2xl font-semibold text-gray-800"
- Body: "text-base text-gray-600"

EXAMPLES:

Simple Button:
#[wasm_bindgen]
pub fn render() -> String {
    let doc = window().unwrap().document().unwrap();
    let body = doc.body().unwrap();
    
    body.set_inner_html(r#"
        <div class="p-6 max-w-2xl mx-auto">
            <button class="px-6 py-3 bg-blue-600 text-white rounded-lg">Click Me</button>
        </div>
    "#);
    "rendered".to_string()
}

Static List:
#[wasm_bindgen]
pub fn render() -> String {
    let doc = window().unwrap().document().unwrap();
    let body = doc.body().unwrap();
    
    body.set_inner_html(r#"
        <div class="p-6 max-w-2xl mx-auto">
            <h1 class="text-4xl font-bold mb-6">My List</h1>
            <ul class="space-y-2">
                <li class="p-4 bg-white rounded-lg shadow">Item 1</li>
                <li class="p-4 bg-white rounded-lg shadow">Item 2</li>
            </ul>
        </div>
    "#);
    "rendered".to_string()
}

IMPORTANT:
- Keep HTML simple - NO complex JavaScript
- Use Tailwind classes for all styling
- Return "rendered" or similar string
- Set inner_html on body element
- ONLY output Rust code, no explanations"#
        .to_string()
}

/// Truncate string
fn truncate(s: &str, max: usize) -> String {
    if s.len() <= max {
        s.to_string()
    } else {
        format!("{}...", &s[..max])
    }
}

/// Base64 encode
fn base64_encode(bytes: &[u8]) -> String {
    use base64::Engine;
    base64::engine::general_purpose::STANDARD.encode(bytes)
}

/// Base64 decode
fn base64_decode(encoded: &str) -> Result<Vec<u8>, AppError> {
    use base64::Engine;
    base64::engine::general_purpose::STANDARD
        .decode(encoded)
        .map_err(|e| AppError::ApiError(format!("Base64 decode error: {}", e)))
}

/// Custom error type
#[derive(Debug)]
enum AppError {
    Anyhow(anyhow::Error),
    Reqwest(reqwest::Error),
    ApiError(String),
}

impl From<anyhow::Error> for AppError {
    fn from(err: anyhow::Error) -> Self {
        AppError::Anyhow(err)
    }
}

impl From<reqwest::Error> for AppError {
    fn from(err: reqwest::Error) -> Self {
        AppError::Reqwest(err)
    }
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AppError::Anyhow(e) => write!(f, "{}", e),
            AppError::Reqwest(e) => write!(f, "{}", e),
            AppError::ApiError(msg) => write!(f, "{}", msg),
        }
    }
}

// ============================================================================
// Design Session Handlers
// ============================================================================

/// Start a new interactive design session
async fn design_start(
    State(state): State<AppState>,
    Json(req): Json<DesignStartRequest>,
) -> Result<Json<DesignStartResponse>, AppError> {
    info!("Starting design session: {}", req.prompt);

    // Check if there's already an active session
    let mut session_lock = state.design_session.lock().await;
    if session_lock.is_some() {
        return Err(AppError::ApiError(
            "Design session already active. Cancel or commit it first.".to_string(),
        ));
    }

    let mut logs = Vec::new();
    logs.push(format!("üé® Starting design session: {}", req.prompt));

    // Create new session
    let session_id = uuid::Uuid::new_v4().to_string();
    let mut conversation = Vec::new();
    conversation.push(Message {
        role: "user".to_string(),
        content: create_system_prompt(),
    });
    conversation.push(Message {
        role: "user".to_string(),
        content: format!("Create a WASM component: {}", req.prompt),
    });

    // Generate initial draft
    logs.push("ü§ñ Generating initial draft...".to_string());
    let (draft, updated_conversation) = generate_draft(&state, conversation, &req.prompt, 1, &mut logs).await?;

    let session = DesignSession {
        session_id: session_id.clone(),
        conversation: updated_conversation,
        drafts: vec![draft.clone()],
        current_draft_index: 0,
        original_prompt: req.prompt.clone(),
        started_at: Utc::now(),
    };

    *session_lock = Some(session);
    drop(session_lock);

    let draft_info = create_draft_info(&draft);

    Ok(Json(DesignStartResponse {
        session_id,
        draft: draft_info,
        logs,
    }))
}

/// Refine the current design with user feedback
async fn design_refine(
    State(state): State<AppState>,
    Json(req): Json<DesignRefineRequest>,
) -> Result<Json<DesignRefineResponse>, AppError> {
    info!("Refining design: {}", req.feedback);

    let mut session_lock = state.design_session.lock().await;
    let session = session_lock.as_mut()
        .ok_or_else(|| AppError::ApiError("No active design session".to_string()))?;

    let mut logs = Vec::new();
    logs.push(format!("üí¨ User feedback: {}", req.feedback));

    // Add user feedback to conversation
    session.conversation.push(Message {
        role: "user".to_string(),
        content: req.feedback.clone(),
    });

    let iteration = session.drafts.len() + 1;
    logs.push(format!("üîÑ Generating iteration {}...", iteration));

    // Generate new draft based on feedback
    let (draft, updated_conversation) = generate_draft(
        &state,
        session.conversation.clone(),
        &req.feedback,
        iteration,
        &mut logs
    ).await?;

    session.conversation = updated_conversation;
    session.drafts.push(draft.clone());
    session.current_draft_index = session.drafts.len() - 1;

    let draft_info = create_draft_info(&draft);

    drop(session_lock);

    Ok(Json(DesignRefineResponse {
        success: true,
        draft: draft_info,
        logs,
        error: None,
    }))
}

/// Commit the current design to version history
async fn design_commit(
    State(state): State<AppState>,
    Json(req): Json<DesignCommitRequest>,
) -> Result<Json<DesignCommitResponse>, AppError> {
    info!("Committing design");

    let mut session_lock = state.design_session.lock().await;
    let session = session_lock.take()
        .ok_or_else(|| AppError::ApiError("No active design session".to_string()))?;

    let current_draft = &session.drafts[session.current_draft_index];

    // Ensure the draft compiled successfully
    let wasm_base64 = current_draft.wasm_base64.as_ref()
        .ok_or_else(|| AppError::ApiError("Current draft has compilation errors. Fix them before committing.".to_string()))?;

    // Decode WASM
    let wasm_bytes = base64_decode(wasm_base64)?;

    // Add to version history
    let mut history = state.versions.lock().await;
    let commit_message = req.message.unwrap_or_else(|| session.original_prompt.clone());
    let version_name = format!("Design: {}", truncate(&commit_message, 40));
    
    let version_id = history.add_version(
        version_name,
        commit_message,
        current_draft.rust_code.clone(),
        wasm_bytes.clone(),
        true,
    );

    drop(history);
    drop(session_lock);

    Ok(Json(DesignCommitResponse {
        success: true,
        version_id,
        wasm_base64: wasm_base64.clone(),
        error: None,
    }))
}

/// Get current design preview
async fn design_preview(
    State(state): State<AppState>,
) -> Result<Json<DesignPreviewResponse>, AppError> {
    let session_lock = state.design_session.lock().await;

    if let Some(session) = session_lock.as_ref() {
        let current_draft = &session.drafts[session.current_draft_index];
        let draft_info = create_draft_info(current_draft);

        let conversation_entries: Vec<ConversationEntry> = session.conversation
            .iter()
            .filter(|msg| msg.role != "system")
            .enumerate()
            .map(|(i, msg)| ConversationEntry {
                role: msg.role.clone(),
                content: msg.content.clone(),
                timestamp: session.started_at + chrono::Duration::seconds(i as i64),
            })
            .collect();

        Ok(Json(DesignPreviewResponse {
            active: true,
            session_id: Some(session.session_id.clone()),
            draft: Some(draft_info),
            conversation: conversation_entries,
        }))
    } else {
        Ok(Json(DesignPreviewResponse {
            active: false,
            session_id: None,
            draft: None,
            conversation: Vec::new(),
        }))
    }
}

/// Cancel the current design session
async fn design_cancel(
    State(state): State<AppState>,
) -> Result<Json<serde_json::Value>, AppError> {
    let mut session_lock = state.design_session.lock().await;
    *session_lock = None;
    Ok(Json(serde_json::json!({ "success": true })))
}

// Helper function to generate a draft with automatic compilation retry
async fn generate_draft(
    state: &AppState,
    mut conversation: Vec<Message>,
    prompt: &str,
    iteration: usize,
    logs: &mut Vec<String>,
) -> Result<(ComponentDraft, Vec<Message>), AppError> {
    const MAX_COMPILATION_RETRIES: u32 = 5;
    
    for attempt in 1..=MAX_COMPILATION_RETRIES {
        if attempt > 1 {
            logs.push(format!("\nüîÑ Compilation retry attempt {}/{}...", attempt, MAX_COMPILATION_RETRIES));
        }
        
        // Call AI
        logs.push("ü§ñ Asking AI to generate code...".to_string());
        
        // Temporarily set conversation
        let mut conv_lock = state.conversation.lock().await;
        *conv_lock = conversation.clone();
        drop(conv_lock);

        let rust_code = match call_claude_api(state).await {
            Ok(code) => {
                logs.push(format!("‚úì Generated {} bytes of code", code.len()));
                code
            }
            Err(e) => {
                return Err(e);
            }
        };

        // Add AI response to conversation
        conversation.push(Message {
            role: "assistant".to_string(),
            content: rust_code.clone(),
        });

        // Try to compile
        logs.push("‚öôÔ∏è  Compiling...".to_string());
        match state.compiler.compile(&rust_code).await {
            Ok(wasm_bytes) => {
                // SUCCESS! Return the working draft
                logs.push(format!("‚úÖ Compiled successfully! {} bytes", wasm_bytes.len()));
                if attempt > 1 {
                    logs.push(format!("üéâ Success after {} attempts", attempt));
                }
                
                let draft = ComponentDraft {
                    iteration,
                    prompt: prompt.to_string(),
                    rust_code,
                    wasm_base64: Some(base64_encode(&wasm_bytes)),
                    compilation_error: None,
                    created_at: Utc::now(),
                };

                return Ok((draft, conversation));
            }
            Err(e) => {
                // Compilation failed
                let error_msg = e.to_string();
                logs.push(format!("‚ùå Compilation failed: {}", error_msg));
                
                if attempt < MAX_COMPILATION_RETRIES {
                    // Add error feedback to conversation for AI to fix
                    logs.push("üîÑ Asking AI to fix compilation errors...".to_string());
                    conversation.push(Message {
                        role: "user".to_string(),
                        content: format!(
                            "That code failed to compile with this error:\n\n{}\n\nPlease fix it and generate working code.",
                            error_msg
                        ),
                    });
                    // Loop continues for retry
                } else {
                    // Max retries reached, return the failed draft
                    logs.push(format!("‚ö†Ô∏è  Max compilation attempts ({}) reached", MAX_COMPILATION_RETRIES));
                    logs.push("üí° The draft has errors - you can provide feedback to help the AI fix them".to_string());
                    
                    let draft = ComponentDraft {
                        iteration,
                        prompt: prompt.to_string(),
                        rust_code,
                        wasm_base64: None,
                        compilation_error: Some(error_msg),
                        created_at: Utc::now(),
                    };

                    return Ok((draft, conversation));
                }
            }
        }
    }

    // This should never be reached due to the logic above, but required for completeness
    Err(AppError::ApiError("Unexpected error in generate_draft loop".to_string()))
}

// Helper to convert ComponentDraft to DraftInfo
fn create_draft_info(draft: &ComponentDraft) -> DraftInfo {
    DraftInfo {
        iteration: draft.iteration,
        prompt: draft.prompt.clone(),
        wasm_base64: draft.wasm_base64.clone(),
        compilation_error: draft.compilation_error.clone(),
        has_runtime_error: false, // Frontend will update this
    }
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::Anyhow(e) => (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()),
            AppError::Reqwest(e) => (StatusCode::BAD_GATEWAY, e.to_string()),
            AppError::ApiError(msg) => (StatusCode::BAD_GATEWAY, msg),
        };

        (status, Json(serde_json::json!({ "error": message }))).into_response()
    }
}
